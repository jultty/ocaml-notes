\documentclass[11pt]{article}

    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Keep aspect ratio if custom image width or height is specified
    \setkeys{Gin}{keepaspectratio}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro

    \usepackage{iftex}
    \ifPDFTeX
        \usepackage[T1]{fontenc}
        \IfFileExists{alphabeta.sty}{
              \usepackage{alphabeta}
          }{
              \usepackage[mathletters]{ucs}
              \usepackage[utf8x]{inputenc}
          }
    \else
        \usepackage{fontspec}
        \usepackage{unicode-math}
    \fi

    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage{array}     % table support for pandoc >= 2.11.3
    \usepackage{calc}      % table minipage width calculation for pandoc >= 2.11.1
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{soul}      % strikethrough (\st) support for pandoc >= 3.0.0
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}

    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}


    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{scripting}
    
    
    
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.61,0.40,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.80,0.25,0.22}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.46,0.46,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.41,0.47,0.13}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.36,0.12}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.52,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{0.89,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@ges}{\let\PY@bf=\textbf\let\PY@it=\textit}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb.
    \makeatletter
        \newbox\Wrappedcontinuationbox
        \newbox\Wrappedvisiblespacebox
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}}
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}}
        \newcommand*\Wrappedcontinuationindent {3ex }
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox}
        % Take advantage of the already applied Pygments mark-up to insert
        % potential linebreaks for TeX processing.
        %        {, <, #, %, $, ' and ": go to next line.
        %        _, }, ^, &, >, - and ~: stay at end of broken line.
        % Use of \textquotesingle for straight quote.
        \newcommand*\Wrappedbreaksatspecials {%
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}%
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}%
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}%
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}%
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}%
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}%
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}%
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}%
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}%
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}%
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}%
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}%
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}%
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}%
        }
        % Some characters . , ; ? ! / are not pygmentized.
        % This macro makes them "active" and they will insert potential linebreaks
        \newcommand*\Wrappedbreaksatpunct {%
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}%
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}%
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}%
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}%
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}%
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}%
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}%
            \catcode`\.\active
            \catcode`\,\active
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active
            \lccode`\~`\~
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%

        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}

    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    
    

    
    \hypertarget{scripting-with-ocaml}{%
\section{Scripting with OCaml}\label{scripting-with-ocaml}}

    OCaml can be used for scripting without much setting up. A shebang at
the start of an OCaml file is ignored. Single-file scripts still get to
access opam-installed libraries.

For this script, I used an \texttt{utop} shebang:

    \begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#!/usr/bin/env utop}
\end{Highlighting}
\end{Shaded}

    The goal here was to replace a simple bash function I used to edit
scripts in my \texttt{PATH}:

    \begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function}\FunctionTok{ nvw} \KeywordTok{\{}
  \VariableTok{args}\OperatorTok{=}\VariableTok{()}
  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \VariableTok{$@}\KeywordTok{;} \ControlFlowTok{do}
    \ControlFlowTok{if} \KeywordTok{[[} \OtherTok{{-}f} \VariableTok{$(}\FunctionTok{which} \StringTok{"}\VariableTok{$i}\StringTok{"}\VariableTok{)} \KeywordTok{]];} \ControlFlowTok{then}
      \VariableTok{args}\OperatorTok{+=}\StringTok{"}\VariableTok{$(}\FunctionTok{which} \VariableTok{$i)}\StringTok{"}
    \ControlFlowTok{else}
      \BuiltInTok{echo} \StringTok{"}\VariableTok{$i}\StringTok{"}\NormalTok{ not found on PATH}
    \ControlFlowTok{fi}
  \ControlFlowTok{done}

  \ControlFlowTok{if} \KeywordTok{[[} \VariableTok{$args} \KeywordTok{]];} \ControlFlowTok{then}
    \BuiltInTok{echo} \StringTok{"[nvw] Editing }\VariableTok{$args}\StringTok{"}
    \ExtensionTok{nvim} \AttributeTok{{-}p} \VariableTok{$args}
  \ControlFlowTok{fi}
\KeywordTok{\}}
\end{Highlighting}
\end{Shaded}

    While this worked as intended, at some point I wanted the function to
also stage the edited files and launch an editor for the commit message,
so I added the following to the bottom:

    \begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ a }\KeywordTok{in} \StringTok{"}\VariableTok{$\{args}\OperatorTok{[*]}\VariableTok{\}}\StringTok{"}\KeywordTok{;} \ControlFlowTok{do}
  \VariableTok{dir}\OperatorTok{=}\VariableTok{$(}\FunctionTok{dirname} \VariableTok{$a)}
  \BuiltInTok{cd} \VariableTok{$dir}
  \FunctionTok{git}\NormalTok{ add }\StringTok{"}\VariableTok{$a}\StringTok{"}
  \FunctionTok{git}\NormalTok{ commit }\AttributeTok{{-}e} \AttributeTok{{-}m} \StringTok{"}\VariableTok{$(}\FunctionTok{basename} \VariableTok{$a)}\StringTok{: "}
  \BuiltInTok{cd} \AttributeTok{{-}}
\ControlFlowTok{done}
\end{Highlighting}
\end{Shaded}

    The downside was that this didn't really check if the file had been
changed at all. Adding this feature would further increase the
function's complexity, so because I wanted to give OCaml scripting
another try I started trying to implement it in OCaml.

    \hypertarget{choosing-my-weapons}{%
\subsection{Choosing my weapons}\label{choosing-my-weapons}}

    While searching online, I found several resources related to scripting:

\begin{itemize}
\tightlist
\item
  \href{https://ocaml.org/p/shexp/latest/doc/Shexp_process/index.html}{shexp
  v0.16.0 (latest) Â· OCaml Package}
\item
  \href{https://erratique.ch/software/cmdliner/doc/Cmdliner/}{Cmdliner
  (cmdliner.Cmdliner)}
\item
  \href{http://ocaml.github.io/ocamlunix/}{Unix system programming in
  OCaml}
\end{itemize}

While \texttt{shexp} was the most popular, I couldn't find much
documentation aside from the one linked above. \texttt{Cmdliner} seemed
to have a bit more.

In the end, I ended up choosing to use neither as it seems that a lot is
possible using just the \texttt{Unix} and \texttt{Sys} modules that are
provided by the OCaml API itself:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{open} \PY{n+nc}{Unix} \PY{o}{;;}
\PY{k}{open} \PY{n+nc}{Sys} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{utility-functions}{%
\subsection{Utility functions}\label{utility-functions}}

    For no good reason other than toying with my first OCaml script, I wrote
the following three functions in order to standardize output when
logging for debug purposes.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{start} \PY{n}{s} \PY{o}{=} \PY{n}{print\PYZus{}endline} \PY{o}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{,\PYZhy{}\PYZlt{} }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{n}{s}\PY{o}{)}
\PY{k}{let} \PY{n}{step} \PY{n}{s} \PY{o}{=} \PY{n}{print\PYZus{}endline} \PY{o}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{| }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{n}{s}\PY{o}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val start : string -> unit = <fun>

\end{Verbatim}
\end{tcolorbox}
        
            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val step : string -> unit = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    Writing this script, I used the \texttt{\^{}} operator a lot, which
concatenates strings together.

    \texttt{start} prints a newline and \texttt{,-\textless{}} before its
message, \texttt{step} prints a \texttt{\textbar{}} before its message
and \texttt{finish} prints \texttt{\textquotesingle{}-\textgreater{}}
before its message.

Combined, they allow output that looks like this:

\begin{verbatim}
,-< Generating hashes
| 60ce0778b6d6ae5 ...
| 9826a40a4966797 ...
| eb509d241c7f22d ...
'-> Done
\end{verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{finish} \PY{o}{?}\PY{o}{(}\PY{n}{s} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Done}\PY{l+s+s2}{\PYZdq{}}\PY{o}{)} \PY{n+nb+bp}{()} \PY{o}{=} \PY{n}{print\PYZus{}endline} \PY{o}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZsq{}\PYZhy{}\PYZgt{} }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{n}{s}\PY{o}{)} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val finish : ?s:string -> unit -> unit = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    One useful thing I learned writing \texttt{finish} was how to use
optional arguments that have default parameter values. The
\texttt{finish} method can be called with \texttt{()} as a single
argument to print its default ``Done'' message, or with a custom one:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{finish} \PY{o}{\PYZti{}}\PY{n}{s}\PY{o}{:}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{A custom message}\PY{l+s+s2}{\PYZdq{}} \PY{n+nb+bp}{()} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
'-> A custom message
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
- : unit = ()

\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{finish} \PY{n+nb+bp}{()} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
'-> Done
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
- : unit = ()

\end{Verbatim}
\end{tcolorbox}
        
    Next I define a few other utility functions.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{run} \PY{n}{c} \PY{o}{=} \PY{n}{input\PYZus{}line} \PY{o}{(}\PY{n}{open\PYZus{}process\PYZus{}in} \PY{n}{c}\PY{o}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val run : string -> string = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    \texttt{run} reads into a string the output of a command \texttt{c}
called by \texttt{open\_process\_in}. This avoids repetition every time
the output of a command is needed.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{confirm} \PY{n+nb+bp}{()} \PY{o}{=} \PY{k}{if} \PY{o}{(}\PY{n}{command} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{gum confirm \PYZsq{}Continue?\PYZsq{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{!=} \PY{l+m+mi}{0}\PY{o}{)} \PY{k}{then} \PY{n}{exit} \PY{l+m+mi}{0} \PY{k}{else} \PY{n+nb+bp}{()}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val confirm : unit -> unit = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    The confirm dialog leverages \href{https://charm.sh/}{Charm}'s
\href{https://github.com/charmbracelet/gum}{\texttt{gum}}, which I used
in my previous scripts and wanted to see how well it would fit here.

It prompts the user with a ``Continue? Yes/No'' dialog and exits the
script if the answer is no.

    \hypertarget{argument-parsing}{%
\subsection{Argument parsing}\label{argument-parsing}}

    Next comes the parsing of the received arguments. The first thing is
discarding argument 0 (the script itself) and then converting that slice
to a List:

    \begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ args = }\DataTypeTok{Array}\NormalTok{.to\_list}
\NormalTok{  (}\DataTypeTok{Array}\NormalTok{.sub }\DataTypeTok{Sys}\NormalTok{.argv }\DecValTok{1}\NormalTok{ (}\DataTypeTok{Array}\NormalTok{.length }\DataTypeTok{Sys}\NormalTok{.argv {-} }\DecValTok{1}\NormalTok{)) ;;}
\end{Highlighting}
\end{Shaded}

    Since this code runs in a Jupyter kernel, let's mock somefilepaths. The
first one actually exists, the second doesn't:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{args} \PY{o}{=} \PY{o}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{/home/juno/.jj/bin/nvw}\PY{l+s+s2}{\PYZdq{}}\PY{o}{;} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{/x/y/z}\PY{l+s+s2}{\PYZdq{}}\PY{o}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val args : string list = ["/home/juno/.jj/bin/nvw"; "/x/y/z"]

\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{path-validation}{%
\subsection{Path validation}\label{path-validation}}

    Because I will use \texttt{which} to get the absolute filepaths from the
environment's \texttt{PATH} variable, I also decide to use it to filter
out any paths that do not correspond to a file.

    To achieve this, the following function will return \texttt{true} if the
exit code is \texttt{0}, meaning the file exists and is on
\texttt{PATH}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{get\PYZus{}exit} \PY{n}{c} \PY{o}{=} \PY{n}{command} \PY{o}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{which }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{n}{c} \PY{o}{\PYZca{}} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ \PYZgt{} /dev/null}\PY{l+s+s2}{\PYZdq{}}\PY{o}{)} \PY{o}{=} \PY{l+m+mi}{0}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val get\_exit : string -> bool = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    There might be a better way to discard stdout? I did not look into it.

    for the actual filtering, I use this pattern matching pattern based on
an identical example
\href{https://cs3110.github.io/textbook/chapters/hop/filter.html}{found
in Cornell University's CS 3110 textbook}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{k}{rec} \PY{n}{filter\PYZus{}empty} \PY{o}{=} \PY{k}{function}
  \PY{o}{|} \PY{n+nb+bp}{[]} \PY{o}{\PYZhy{}\PYZgt{}} \PY{n+nb+bp}{[]}
  \PY{o}{|} \PY{n}{h} \PY{o}{::} \PY{n}{t} \PY{o}{\PYZhy{}\PYZgt{}} \PY{k}{if} \PY{n}{get\PYZus{}exit} \PY{n}{h} \PY{k}{then} \PY{n}{h} \PY{o}{::} \PY{n}{filter\PYZus{}empty} \PY{n}{t} \PY{k}{else} \PY{n}{filter\PYZus{}empty} \PY{n}{t} \PY{o}{;;}

\PY{k}{let} \PY{n}{existing\PYZus{}paths} \PY{o}{=} \PY{n}{filter\PYZus{}empty} \PY{n}{args} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val filter\_empty : string list -> string list = <fun>

\end{Verbatim}
\end{tcolorbox}
        
            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val existing\_paths : string list = ["/home/juno/.jj/bin/nvw"]

\end{Verbatim}
\end{tcolorbox}
        
    By just looking at it at first I had no idea what it meant. After a
step-by-step explanation from a friendly bot, I figured the function
works like this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  If the received list is empty, return an empty list
\item
  If it's not empty, divide it into \texttt{h} (head) and \texttt{t}
  (tail)
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{h} is the single first element of the list
\item
  \texttt{t} is all other elements
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Apply \texttt{get\_exit} to \texttt{h}
\item
  If \texttt{get\_exit} returns \texttt{true}, prepend \texttt{h} to the
  result of the recursion on \texttt{t}
\item
  If \texttt{get\_exit} returns \texttt{false}, recurse on \texttt{t}
  alone, effectively discarding \texttt{h}
\end{enumerate}

    Now that a list of valid candidates for absolute paths is available we
can assemble a list of such paths.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{which} \PY{n}{s} \PY{o}{=} \PY{n}{run} \PY{o}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{which }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{n}{s}\PY{o}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val which : string -> string = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    This \texttt{which} function takes a string and returns the full path
from the output of \texttt{which} on \texttt{s}.

    With this function, we can use \texttt{List.map} to produce a list of
paths:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{paths} \PY{o}{=} \PY{n+nn}{List}\PY{p}{.}\PY{n}{map} \PY{n}{which} \PY{n}{existing\PYZus{}paths} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val paths : string list = ["/home/juno/.jj/bin/nvw"]

\end{Verbatim}
\end{tcolorbox}
        
    As intended, the mocked \texttt{/x/y/z} path didn't make it into this
list.

    With this list of absolute, valid paths, we can also create a single
space-separated string to pass to the editor.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{arg\PYZus{}paths} \PY{o}{=} \PY{n+nn}{String}\PY{p}{.}\PY{n}{concat} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ }\PY{l+s+s2}{\PYZdq{}} \PY{n}{paths} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val arg\_paths : string = "/home/juno/.jj/bin/nvw"

\end{Verbatim}
\end{tcolorbox}
        
    Note that this assumes the paths don't contain spaces. If this
assumption can't be made, they should be wrapped in quotes.

    \hypertarget{hashing-and-editing}{%
\subsection{Hashing and editing}\label{hashing-and-editing}}

    Next, we need functions to produce hashes for the files before and after
the editor is called, to know if there have been any changes.

    \texttt{hash\_cmd} returns a string containing a sha256sum invocation
using argument \texttt{f} as the filename and piping to \texttt{cut} in
order to store the hash only.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{hash\PYZus{}cmd} \PY{n}{f} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{sha256sum }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{n}{f} \PY{o}{\PYZca{}} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ | cut \PYZhy{}d \PYZsq{} \PYZsq{} \PYZhy{}f 1}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val hash\_cmd : string -> string = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    Probably a better idea to use OCaml itself for what \texttt{cut} is
being used here.

    Now the returned hash from each execution of \texttt{hash\_cmd} can be
stored with the absolute path as the key. This is what
\texttt{table\_add} does:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{table\PYZus{}add} \PY{n}{t} \PY{n}{k} \PY{o}{=} \PY{n+nn}{Hashtbl}\PY{p}{.}\PY{n}{add} \PY{n}{t} \PY{n}{k} \PY{o}{(}\PY{n}{run} \PY{o}{(}\PY{n}{hash\PYZus{}cmd} \PY{n}{k}\PY{o}{)}\PY{o}{)} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val table\_add : (string, string) Hashtbl.t -> string -> unit = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    \texttt{table\_add} takes arguments \texttt{t} (table) and \texttt{k}
(key).

It then calls \texttt{Hashtbl.add} on the table with \texttt{k} as the
key and the output of \texttt{run\ (hash\_cmd\ k)} as the value. Since
\texttt{run} was already defined to return the output of a command, the
output from \texttt{sha256sum} gets stored in the hashmap as the value
for a key matching the absolute filepath.

    Now a table can be created using the length of the \texttt{paths} list.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{table} \PY{o}{=} \PY{n+nn}{Hashtbl}\PY{p}{.}\PY{n}{create} \PY{o}{(}\PY{n+nn}{List}\PY{p}{.}\PY{n}{length} \PY{n}{paths}\PY{o}{)} \PY{o}{;;}
\PY{n+nn}{List}\PY{p}{.}\PY{n}{map} \PY{o}{(}\PY{n}{table\PYZus{}add} \PY{n}{table}\PY{o}{)} \PY{n}{paths} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val table : ('\_weak1, '\_weak2) Hashtbl.t = <abstr>

\end{Verbatim}
\end{tcolorbox}
        
            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
- : unit list = [()]

\end{Verbatim}
\end{tcolorbox}
        
    By using \texttt{List.map\ (table\_add\ table)\ paths}, each path is
passed as \texttt{table\_add}'s \texttt{k} argument, which produces the
hash from running the assembled \texttt{hash\_cmd} and stores it as the
corrresponding value.

    For debugging purposes, I initially had this moment freeze before
launching an editor, to check for potential errors. I ended up
commenting it out later, and in the end removing it entirely.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c}{(*}\PY{c}{ confirm }\PY{c}{(}\PY{c}{)}\PY{c}{ ;; }\PY{c}{*)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ config\_path = }\StringTok{"/home/user/.config/nvim/commit.lua"}
\KeywordTok{let}\NormalTok{ cmd = }\StringTok{"nvim {-}u "}\NormalTok{ \^{} config\_path \^{} }\StringTok{" {-}p "}\NormalTok{ \^{} arg\_paths ;;}
\KeywordTok{let}\NormalTok{ editor\_exit = command cmd ;;}
\end{Highlighting}
\end{Shaded}

    Calling the editor would heavily depend on the user and their
environment. Above is an example similar to what I used, with a custom
configuration file and a \texttt{-p} flag for opening each file as a
tab.

    The most important thing is passing \texttt{arg\_paths} to the editor so
the target files can be edited. So the three lines above could also be
simply:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{command (}\StringTok{"nvim "}\NormalTok{ \^{} arg\_paths) ;;}
\end{Highlighting}
\end{Shaded}

    After the editor exits, the hashes need to be recalculated and stored in
a different table:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{post\PYZus{}table} \PY{o}{=} \PY{n+nn}{Hashtbl}\PY{p}{.}\PY{n}{create} \PY{o}{(}\PY{n+nn}{List}\PY{p}{.}\PY{n}{length} \PY{n}{paths}\PY{o}{)} \PY{o}{;;}
\PY{n+nn}{List}\PY{p}{.}\PY{n}{map} \PY{o}{(}\PY{n}{table\PYZus{}add} \PY{n}{post\PYZus{}table}\PY{o}{)} \PY{n}{paths} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val post\_table : ('\_weak3, '\_weak4) Hashtbl.t = <abstr>

\end{Verbatim}
\end{tcolorbox}
        
            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
- : unit list = [()]

\end{Verbatim}
\end{tcolorbox}
        
    Here I reuse the functions initially used for populating the first
table. They weren't as reusable before I had to replicate the same logic
for the second table and realize I could repeat myself less.

    \hypertarget{committing}{%
\subsection{Committing}\label{committing}}

    With files changed and pre and post-editing hashes available through
their absolute paths, now we must assemble the appropriate git commands
to add and commit the changes \emph{in case} the hashes differ.

    Since file and Git root paths will be needed by Git, the following
utility functions were written to supply those:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{get\PYZus{}dir} \PY{n}{f} \PY{o}{=} \PY{n}{run} \PY{o}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{dirname }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{n}{f}\PY{o}{)} \PY{o}{;;}
\PY{k}{let} \PY{n}{get\PYZus{}root} \PY{n}{f} \PY{o}{=} \PY{n}{run} \PY{o}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{git rev\PYZhy{}parse \PYZhy{}\PYZhy{}show\PYZhy{}toplevel }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{n}{get\PYZus{}dir} \PY{n}{f}\PY{o}{)} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val get\_dir : string -> string = <fun>

\end{Verbatim}
\end{tcolorbox}
        
            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val get\_root : string -> string = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    These \texttt{get\_*} functions will take a given absolute path to a
file and return its containing directory or the root of its Git repo.

    The \texttt{git\_*} commands then use these functions to assemble full
\texttt{git} commands with arguments that allow calling \texttt{nvw}
from any directory and still affect only the repository where each file
belongs.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{git\PYZus{}pre} \PY{n}{f} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{git \PYZhy{}C }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{o}{(}\PY{n}{get\PYZus{}dir} \PY{n}{f}\PY{o}{)} \PY{o}{;;}
\PY{k}{let} \PY{n}{git\PYZus{}add} \PY{n}{f} \PY{o}{=} \PY{o}{(}\PY{n}{git\PYZus{}pre} \PY{n}{f}\PY{o}{)} \PY{o}{\PYZca{}} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ add }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{n}{f} \PY{o}{;;}
\PY{k}{let} \PY{n}{git\PYZus{}commit} \PY{n}{f} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{lazygit \PYZhy{}p }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{o}{(}\PY{n}{get\PYZus{}root} \PY{n}{f}\PY{o}{)} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val git\_pre : string -> string = <fun>

\end{Verbatim}
\end{tcolorbox}
        
            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val git\_add : string -> string = <fun>

\end{Verbatim}
\end{tcolorbox}
        
            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val git\_commit : string -> string = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    I prefer
\href{https://github.com/jesseduffield/lazygit}{\texttt{lazygit}} here
because a lot more information becomes available and several operations
are possible before exiting, as opposed to locking oneself into the
editor with just commit and abort possible.

    Finally, \texttt{diff\_hashes} will take a single absolute path as
argument and look it up on both tables, returning \texttt{true} only
when they are \textbf{different}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{diff\PYZus{}hashes} \PY{n}{k} \PY{o}{=} \PY{o}{(}\PY{n+nn}{Hashtbl}\PY{p}{.}\PY{n}{find} \PY{n}{table} \PY{n}{k}\PY{o}{)} \PY{o}{\PYZlt{}}\PY{o}{\PYZgt{}} \PY{o}{(}\PY{n+nn}{Hashtbl}\PY{p}{.}\PY{n}{find} \PY{n}{post\PYZus{}table} \PY{n}{k}\PY{o}{)} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val diff\_hashes : string -> bool = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    Since \texttt{diff\_hashes} operates on this single argument, we can
wrap another function around it that will execute the assembled git
commands only if \texttt{diff\_hashes} returns true.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{22}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{let} \PY{n}{call\PYZus{}git\PYZus{}if\PYZus{}hashes\PYZus{}diff} \PY{n}{f} \PY{o}{=} \PY{k}{begin}
  \PY{k}{if} \PY{n}{diff\PYZus{}hashes} \PY{n}{f} \PY{k}{then} \PY{k}{begin}
    \PY{n}{ignore} \PY{o}{(}\PY{n}{command} \PY{o}{(}\PY{n}{git\PYZus{}add} \PY{n}{f}\PY{o}{)}\PY{o}{)}\PY{o}{;}
    \PY{n}{ignore} \PY{o}{(}\PY{n}{command} \PY{o}{(}\PY{n}{git\PYZus{}commit} \PY{n}{f}\PY{o}{)}\PY{o}{)}\PY{o}{;}
  \PY{k}{end} \PY{k}{else}
    \PY{n}{step} \PY{o}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Skipped: }\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZca{}} \PY{n}{f} \PY{o}{\PYZca{}} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ matched hashes}\PY{l+s+s2}{\PYZdq{}}\PY{o}{)} \PY{o}{;}
\PY{k}{end} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{22}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
val call\_git\_if\_hashes\_diff : string -> unit = <fun>

\end{Verbatim}
\end{tcolorbox}
        
    The \texttt{ignore} function is used here to discard the return values.
It is not needed, but gets rid of compiler warnings regarding the
unexpected return of the command's exit code.

    Now, using \texttt{List.map} we can apply
\texttt{call\_git\_if\_hashes\_diff} to every path. This in turn will
call \texttt{diff\_hashes} and compare the hashes present on both pre
and post-edit tables.

    If the hashes differ, it will call \texttt{git\_add} and
\texttt{git\_commit} for each file.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nn}{List}\PY{p}{.}\PY{n}{map} \PY{n}{call\PYZus{}git\PYZus{}if\PYZus{}hashes\PYZus{}diff} \PY{n}{paths} \PY{o}{;;}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
| Skipped: /home/juno/.jj/bin/nvw matched hashes
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
- : unit list = [()]

\end{Verbatim}
\end{tcolorbox}
        Since in this notebook the editor is never really called, the output states that the hashes have matched.
    \hypertarget{references}{%
\subsection{References}\label{references}}

    \begin{itemize}
\tightlist
\item
  \href{https://v2.ocaml.org/api/Sys.html\#top}{OCaml library : Sys}
\item
  \href{https://v2.ocaml.org/api/Unix.html}{OCaml library : Unix}
\item
  \href{https://v2.ocaml.org/api/List.html}{OCaml library : List}
\item
  \href{https://v2.ocaml.org/api/Map.S.html}{OCaml library : Map.S}
\item
  \href{https://v2.ocaml.org/api/String.html}{OCaml library : String}
\item
  \href{https://v2.ocaml.org/api/Array.html}{OCaml library : Array}
\item
  \href{https://v2.ocaml.org/releases/5.1/api/Stdlib.html\#EXCEPTIONEnd_of_file}{OCaml
  library : Stdlib}
\item
  \href{https://v2.ocaml.org/manual/lablexamples.html\#sec43}{OCaml -
  Labeled arguments}
\item
  \href{https://dev.realworldocaml.org/maps-and-hashtables.html}{Maps
  and Hash Tables - Real World OCaml}
\item
  \href{https://ocaml.org/docs/mutability-imperative-control-flow\#imperative-control-flow}{Mutability
  and Imperative Control Flow Â· OCaml Documentation}
\item
  \href{https://v2.ocaml.org/manual/expr.html\#ss\%3Aexpr-control}{OCaml
  - The OCaml language: Control structures}
\item
  \href{https://github.com/cs3110/textbook}{4.3. Filter -
  cs3110/textbook: The CS 3110 Textbook}
\end{itemize}


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
